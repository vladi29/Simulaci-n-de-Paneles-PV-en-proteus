CCS PCM C Compiler, Version 5.095d, 1               11-Aug-20 23:53
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Usuario\OneDrive\Escritorio\USB\Verano 2020\Electiva de Electronica de Potencia\Proyecto 2\Simulaci-n-de-Paneles-PV-en-proteus\PIC PWM\CodigoPic16f887.lst

               ROM used:   202 words (2%)
                           Largest free fragment is 2048
               RAM used:   24 (7%) at main() level
                           25 (7%) worst case
               Stack used: 0 locations
               Stack size: 8

0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   029
0003:  NOP
.................... //Vladimir Alfaro - Universidad Simón Bolívar - 09/08/2020 
.................... // Con este código se pretende diseñar el algoritmo de control MMPT para un microcontrolador PIC16F887
.................... //-----------------------------------------------------------------------------------------------------
.................... 
.................... #include <16f887.h>
.................... //////////// Standard Header file for the PIC16F887 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F887
0004:  CLRF   77
0005:  CLRF   78
0006:  MOVF   32,W
0007:  BCF    03.0
0008:  BTFSC  33.0
0009:  ADDWF  77,F
000A:  RRF    77,F
000B:  RRF    78,F
000C:  BTFSC  33.1
000D:  ADDWF  77,F
000E:  RRF    77,F
000F:  RRF    78,F
0010:  BTFSC  33.2
0011:  ADDWF  77,F
0012:  RRF    77,F
0013:  RRF    78,F
0014:  BTFSC  33.3
0015:  ADDWF  77,F
0016:  RRF    77,F
0017:  RRF    78,F
0018:  BTFSC  33.4
0019:  ADDWF  77,F
001A:  RRF    77,F
001B:  RRF    78,F
001C:  BTFSC  33.5
001D:  ADDWF  77,F
001E:  RRF    77,F
001F:  RRF    78,F
0020:  BTFSC  33.6
0021:  ADDWF  77,F
0022:  RRF    77,F
0023:  RRF    78,F
0024:  BTFSC  33.7
0025:  ADDWF  77,F
0026:  RRF    77,F
0027:  RRF    78,F
0028:  RETURN
.................... 
.................... #list
.................... 
.................... #device ADC = 10     // Conversor Analógico Digital con  10 bits de resolución
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP, PUT, BROWNOUT, INTRC_IO
.................... #use delay(clock=4000000)
.................... #byte PORTA = 5
.................... 
.................... int Timer2=10, PostCaler=1, V1, V2=140, I1, I2=10, P1, P2, duty=20;// Preescaler;
.................... //Para 25KHz, el valor para modular el DutyCycle será 40 = 100%
.................... float Vm, Im;
.................... 
.................... void main(){
0029:  MOVF   03,W
002A:  ANDLW  1F
002B:  MOVWF  03
002C:  MOVLW  61
002D:  BSF    03.5
002E:  MOVWF  0F
002F:  CLRF   10
0030:  MOVF   0F,W
0031:  MOVLW  0A
0032:  BCF    03.5
0033:  MOVWF  20
0034:  MOVLW  01
0035:  MOVWF  21
0036:  MOVLW  8C
0037:  MOVWF  23
0038:  MOVLW  0A
0039:  MOVWF  25
003A:  MOVLW  14
003B:  MOVWF  28
003C:  MOVLW  FF
003D:  MOVWF  31
003E:  BSF    03.5
003F:  BSF    03.6
0040:  MOVF   09,W
0041:  ANDLW  C0
0042:  MOVWF  09
0043:  BCF    03.6
0044:  BCF    1F.4
0045:  BCF    1F.5
0046:  MOVLW  00
0047:  BSF    03.6
0048:  MOVWF  08
0049:  BCF    03.5
004A:  CLRF   07
004B:  CLRF   08
004C:  CLRF   09
004D:  BCF    03.7
....................     
....................     //Para la PWM de 1Khz es necesario un Timer2=249, cuando la frecuencia del cristal es de 4Mhz,
....................     //el PostCaler=1 y Preescaler=4, en base a la siguiente fórmula:
....................     // Timer2 = (Td*fxtal/(4*Preescaler-PostCaler)) - 1
....................     //Timer2 = 10;                                    //Para este valor del Timer se puede alcanzar una f=25KHz
....................     //PostCaler = 1;                                  // Sólo puede tomar valores de 1, 4 o 16, igual que el preescaler
....................     //Preescaler = 4;
....................     set_tris_a(0b00000011);                           //Configuro los pines RA0 y RA1 como entradas
004E:  MOVLW  03
004F:  BSF    03.5
0050:  BCF    03.6
0051:  MOVWF  05
....................     setup_timer_2(t2_div_by_4, Timer2, PostCaler);    // Configuración del timer 2
0052:  MOVLW  01
0053:  BCF    03.5
0054:  SUBWF  21,W
0055:  MOVWF  78
0056:  RLF    78,W
0057:  MOVWF  77
0058:  RLF    77,F
0059:  RLF    77,F
005A:  MOVLW  F8
005B:  ANDWF  77,F
005C:  MOVF   77,W
005D:  IORLW  05
005E:  MOVWF  12
005F:  MOVF   20,W
0060:  BSF    03.5
0061:  MOVWF  12
....................     setup_ccp1(ccp_pwm);                              // Con esto estamos configurando el modo PWM en la salida ccp1
0062:  BCF    03.5
0063:  BCF    31.2
0064:  MOVF   31,W
0065:  BSF    03.5
0066:  MOVWF  07
0067:  BCF    03.5
0068:  BCF    07.2
0069:  MOVLW  0C
006A:  MOVWF  17
006B:  BSF    03.5
006C:  CLRF   1B
006D:  CLRF   1C
006E:  MOVLW  01
006F:  MOVWF  1D
....................     setup_adc_ports(all_analog);                      // Todos los puertos analÃ³gicos quedarÃ¡n como analÃ³gicos
0070:  BSF    03.6
0071:  MOVF   09,W
0072:  ANDLW  C0
0073:  IORLW  1F
0074:  MOVWF  09
0075:  BCF    03.6
0076:  BCF    1F.4
0077:  BCF    1F.5
0078:  MOVLW  FF
0079:  BSF    03.6
007A:  MOVWF  08
....................     setup_adc(adc_clock_internal);                    //Configuramos la velocidad del ADC
007B:  BCF    03.5
007C:  BCF    03.6
007D:  BSF    1F.6
007E:  BSF    1F.7
007F:  BSF    03.5
0080:  BSF    1F.7
0081:  BCF    03.5
0082:  BSF    1F.0
....................     set_pwm1_duty(duty);                              //Se confiugura el dutycycle de la PWM
....................     
....................     while(1){
....................        set_adc_channel(0);          //Selecciono el canal 0 (RA0)
0083:  MOVLW  00
0084:  MOVWF  78
0085:  MOVF   1F,W
0086:  ANDLW  C3
0087:  IORWF  78,W
0088:  MOVWF  1F
....................        delay_us(50);                //Retardo de 50 us para leer la data
0089:  MOVLW  10
008A:  MOVWF  77
008B:  DECFSZ 77,F
008C:  GOTO   08B
008D:  NOP
....................        V1=read_adc();                //Guardo en bits el voltaje leido por el canal 0
008E:  BSF    1F.1
008F:  BTFSC  1F.1
0090:  GOTO   08F
0091:  BSF    03.5
0092:  MOVF   1E,W
0093:  BCF    03.5
0094:  MOVWF  22
....................        
....................        set_adc_channel(1);          //Selecciono el canal 1 (RA1)
0095:  MOVLW  04
0096:  MOVWF  78
0097:  MOVF   1F,W
0098:  ANDLW  C3
0099:  IORWF  78,W
009A:  MOVWF  1F
....................        delay_us(50);                //Retardo de 50 us para leer la data
009B:  MOVLW  10
009C:  MOVWF  77
009D:  DECFSZ 77,F
009E:  GOTO   09D
009F:  NOP
....................        I1=read_adc();                //Guardo en bits la corriente leida por el canal 1
00A0:  BSF    1F.1
00A1:  BTFSC  1F.1
00A2:  GOTO   0A1
00A3:  BSF    03.5
00A4:  MOVF   1E,W
00A5:  BCF    03.5
00A6:  MOVWF  24
.................... 
....................    /*-----------Algoritmo MPPT----------*/
....................        P1 = V1*I1;
00A7:  MOVF   22,W
00A8:  MOVWF  32
00A9:  MOVF   24,W
00AA:  MOVWF  33
00AB:  CALL   004
00AC:  MOVF   78,W
00AD:  MOVWF  26
....................        P2 = V2*I2;
00AE:  MOVF   23,W
00AF:  MOVWF  32
00B0:  MOVF   25,W
00B1:  MOVWF  33
00B2:  CALL   004
00B3:  MOVF   78,W
00B4:  MOVWF  27
....................        
....................        if(P1 == P2){
00B5:  MOVF   27,W
00B6:  SUBWF  26,W
00B7:  BTFSS  03.2
00B8:  GOTO   0BB
....................          return;
00B9:  GOTO   0C9
....................        }
00BA:  GOTO   0C8
....................        else{
....................          if(P1 - P2 > 0){
00BB:  MOVF   27,W
00BC:  SUBWF  26,W
00BD:  BTFSC  03.2
00BE:  GOTO   0C4
....................             if(V1 - V2 > 0){
00BF:  MOVF   23,W
00C0:  SUBWF  22,W
00C1:  BTFSS  03.2
....................                //No estoy seguro de que poner aqui
....................             }
00C2:  GOTO   0C3
....................             else{
....................                //No estoy seguro de que poner aqui
....................             }
....................          }
00C3:  GOTO   0C8
....................          else{
....................             if(V1 - V2 > 0){
00C4:  MOVF   23,W
00C5:  SUBWF  22,W
00C6:  BTFSS  03.2
....................                //*No estoy seguro de que poner aqui
....................             }
00C7:  GOTO   0C8
....................             else{
....................                //No estoy seguro de que poner aqui
....................             }
....................          }
....................        }  
00C8:  GOTO   083
....................       }
.................... }
00C9:  SLEEP

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
